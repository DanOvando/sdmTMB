% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/predict.R
\name{predict.sdmTMB}
\alias{predict.sdmTMB}
\title{Predict from an sdmTMB model}
\usage{
\method{predict}{sdmTMB}(object, newdata = NULL, se_fit = FALSE,
  xy_cols = c("X", "Y"), ...)
}
\arguments{
\item{object}{An object from \code{\link[=sdmTMB]{sdmTMB()}}.}

\item{newdata}{An optional new data frame. This should be a single set of
spatial locations. These locations will be expanded to cover all the years
in the original data set. Eventually \code{newdata} will be more flexible.}

\item{se_fit}{Should standard errors on predictions at the new locations given by
\code{newdata} be calculated? Warning: the current implementation can be slow for
large data sets or high-resolution projections.}

\item{xy_cols}{A character vector of length 2 that gives the column names of
the x and y coordinates in \code{newdata}.}

\item{...}{Not implemented.}
}
\value{
A data frame. TODO details.
}
\description{
Can predict on the original data locations or onto new data.
}
\examples{
# We'll only use a small number of knots so this example runs quickly
# but you will likely want to use many more (depending on your data).

pcod_spde <- make_spde(pcod$X, pcod$Y, n_knots = 100)
m <- sdmTMB(
 pcod, density ~ 0 + as.factor(year) + depth_scaled + depth_scaled2,
 time = "year", spde = pcod_spde, family = tweedie(link = "log"),
 silent = FALSE
)

# Predictions at original data locations:
predictions <- predict(m)$data
cols <- c("year", "X", "Y", "est", "est_fe",
  "est_re_s", "est_re_st", "s_i")
head(predictions[,cols])

predictions$resids <- residuals(m) # randomized quantile residuals
library(ggplot2)
ggplot(predictions, aes(X, Y, col = resids)) + scale_colour_gradient2() +
  geom_point() + facet_wrap(~year)
hist(predictions$resids)
qqnorm(predictions$resids);abline(a = 0, b = 1)

# Predictions onto new data:
predictions <- predict(m, newdata = qcs_grid)$data

# A short function for plotting our predictions:
plot_map <- function(dat, column = "est") {
  ggplot(dat, aes_string("X", "Y", fill = column)) +
    geom_raster() +
    facet_wrap(~year) +
    coord_fixed()
}

plot_map(predictions, "exp(est)") +
  scale_fill_viridis_c(trans = "sqrt") +
  ggtitle("Prediction (fixed effects + all random effects)")

plot_map(predictions, "exp(est_fe)") +
  ggtitle("Prediction (fixed effects only)") +
  scale_fill_viridis_c(trans = "sqrt")

plot_map(predictions, "est_re_s") +
  ggtitle("Spatial random effects only") +
  scale_fill_gradient2()

plot_map(predictions, "est_re_st") +
  ggtitle("Spatiotemporal random effects only") +
  scale_fill_gradient2()

\donttest{
# Example with standard errors on new location predictions.
# Note this example models presence/absence.
pcod_2017 <- pcod[pcod$year == 2017, ]
pcod_spde <- make_spde(pcod_2017$X, pcod_2017$Y, n_knots = 75)
m2017 <- sdmTMB(
  pcod_2017, present ~ 0 + depth_scaled + depth_scaled2,
  time = "year", spde = pcod_spde, family = binomial(link = "logit"),
  silent = FALSE
)

# Predictions at new data locations with standard errors.
# Note that this can currently be quite slow on large data sets.
predictions <- predict(m2017, newdata = qcs_grid, se_fit = TRUE)$data

plot_map(predictions, "plogis(est)") +
  scale_fill_gradient2(midpoint = 0.5) +
  ggtitle("Predictions")

plot_map(predictions, "est_se") +
  scale_fill_viridis_c() +
  ggtitle("Prediction standard error")

plot_map(predictions, "plogis(est + 2 * est_se)") +
  scale_fill_gradient2(midpoint = 0.5) +
  ggtitle("Prediction upper 95\% CI")

plot_map(predictions, "plogis(est - 2 * est_se)") +
  scale_fill_gradient2(midpoint = 0.5) +
  ggtitle("Prediction lower 95\% CI")
}
}
